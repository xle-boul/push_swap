/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   quick_sort_second_split.c                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: xle-boul <xle-boul@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/05/14 21:33:28 by xle-boul          #+#    #+#             */
/*   Updated: 2022/05/17 20:08:50 by xle-boul         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/push_swap.h"

// ramene high_a et high_b du bas des listes A et B en meme temps
void	ft_bring_both_bottoms_up(t_stack **a, t_stack **b, int count_a, int count_b)
{
	if (count_a > 0 && count_b > 0)
	{
		while (count_a > 0 && count_b > 0)
		{
			revrotrot(a, b);
			count_a--;
			count_b--;
		}
	}
	while (count_a-- > 0)
		reverse_rotate(b, 'b');
	while (count_b-- > 0)
		reverse_rotate(a, 'a');
}

// remet high_b sur le dessus de A, sauf si la liste A est deja classee
// telle quelle
void	ft_bring_higher_split_back(t_stack **a, t_stack **b, t_ct *n)
{
	int	count_low;
	int	count_high;

	count_low = n->count_low_b;
	count_high = n->count_high_b;
	while (count_low-- > 0)
		reverse_rotate(b, 'b');
	if (ft_check_if_sorted(*a) == 0)
	{
		n->count_high_b = 0;
		return ;
	}
	while (count_high-- > 0)
		push(b, a, 'b');
}

// reprend les donnees des differents sous-segments pour un usage ulterieur
t_splits	ft_second_counters_init(t_ct *n, t_data *data)
{
	t_splits	s;

	s.min_low_a = data->min;
	s.min_high_a = s.min_low_a + n->count_low_a;
	s.min_low_b = s.min_high_a + n->count_high_a;
	s.min_high_b = s.min_low_b + n->count_low_b;
	s.max_low_a = s.min_high_a - 1;
	s.max_high_a = s.min_low_b - 1;
	s.max_low_b = s.min_high_b - 1;
	s.max_high_b = data->max;
	s.to_transfer = n->steps - n->count_high_b;
	return (s);
}

// prepare la structure t_ct qui gÃ¨re les compteurs des differents segments
t_ct	ft_counters_init(t_data *data)
{
	t_ct	n;
	
	n.steps = data->to_transfer;
	n.count_high_a = 0;
	n.count_high_b = 0;
	n.count_low_a = 0;
	n.count_low_b = 0;
	n.new_med_a = n.steps / 4 + data->min;
	n.new_med_b = n.steps / 4 + data->med;
	return (n);
}

void	ft_sort_counters_init(t_splits *s)
{
	s->count_a = 0;
	s->count_b = 0;
}

void	ft_bring_back_from_bottom_b(t_stack **a, t_stack **b, int num)
{
	int	path;

	while (num-- > 0)
	{
		path = ft_find_shortest_path(*b, (*a)->idx - 1);
		if (path > 0)
		{
			while (path-- > 0)
				rotate(b, 'b');
		}
		else if (path < 0)
		{
			while (path++ < 0)
			reverse_rotate(b, 'b');
		}
		push(a, b, 'a');
	ft_printf("after bringing from b\n");
	ft_print_both_lists(*a, *b);
	}
}

void	ft_sort_shit(t_stack **a, t_stack **b, t_splits s, t_ct n)
{
	ft_printf("before start\n");
	ft_print_both_lists(*a, *b);
	ft_sort_counters_init(&s);
	while (n.count_high_b-- > 0)
	{
		ft_printf("in high b\n");
		ft_sort_shit_hb(a, b, &s);
	}
	ft_bring_back_from_bottom_b(a, b, s.count_b);
	ft_bring_back_from_bottom_a(a, s.count_a);
	ft_sort_counters_init(&s);
	while (n.count_low_b-- > 0)
	{
		ft_printf("in low b\n");
		ft_sort_shit_lb(a, b, &s);
	}
	ft_bring_back_from_bottom_b(a, b, s.count_b);
	ft_bring_back_from_bottom_a(a, s.count_a);
	ft_sort_counters_init(&s);
	while (n.count_high_a-- > 0)
	{
		ft_printf("in high a\n");
		ft_sort_shit_ha(a, b, &s);
	}
	ft_bring_back_from_bottom_b(a, b, s.count_b);
	ft_bring_back_from_bottom_a(a, s.count_a);
	ft_sort_counters_init(&s);
	while (n.count_low_a-- > 0)
	{
		ft_printf("in low a\n");
		ft_sort_shit_la(a, b, &s);
	}
	ft_bring_back_from_bottom_b(a, b, s.count_b);
	ft_bring_back_from_bottom_a(a, s.count_a);
}

void	ft_second_split(t_stack **a, t_stack **b, t_data **data)
{
	t_ct		n;
	t_splits	s;

	n = ft_counters_init(*data);
	while (n.steps-- > 0)
	{
		if ((*b)->idx < (*data)->med)
			ft_push_to_top_of_a(a, b, &n);
		else
			ft_split_between_a_and_b(a, b, &n);
	}
	ft_split_a_even_more(a, b, n);
	ft_bring_both_bottoms_up(a, b, n.count_high_a, n.count_high_b);
	ft_bring_higher_split_back(a, b, &n);
	s = ft_second_counters_init(&n, *data);
	ft_printf("minlowa %d maxlowa %d\nminhigha %d maxhigha %d\nminlowb %d maxlowb %d\nminhighb %d maxhighb %d\nto transfer: %d\n", s.min_low_a, s.max_low_a, s.min_high_a, s.max_high_a, s.min_low_b, s.max_low_b, s.min_high_b, s.max_high_b, s.to_transfer);
	ft_sort_shit(a, b, s, n);
	ft_move_data_pointer(data);
	ft_print_med(*data);
	ft_print_both_lists(*a,*b);
}
