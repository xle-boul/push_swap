/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   quick_sort_transfer_a.c4ov5                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: xle-boul <xle-boul@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/05/11 10:03:56 by xle-boul          #+#    #+#             */
/*   Updated: 2022/05/14 15:06:38 by xle-boul         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/push_swap.h"

/* =====================================================
Arguments:
len_tot -> nombre d'elements a transferer depuis B vers A

lance la fonction de tri

Pre-conditions: dans error_handler.c
l'element au fond de A doit etre plus grand que le premier element de A
l'element au fond de B doit etre plus petit que le min du segment
l'element en tete de B doit etre plus petit que l'element en tete de A

scanner le segment (len_tot mouvements vers A) et pour chaque element:
	cas1) envoyer en tete de A s'il est a - 1 ou swap s'il est a - 2
	cas2) envoyer au fond de A s'il est plus petit que la qs.median
	cas3) envoyer au fond de B s'il est plus grand que que qs.median
	
ensuite:
	step1) classer tout ce qui est encore dans B (superieur ou egal au median)
	step2) renvoyer ce qu'on a mis dans A (inferieur au median) dans B
	step3) relancer la fonction de tri avec les donnees des elements revenus de A

post-conditions: dans error_handler.c
compteur doit etre < len_tot

sinon rappeler la meme fonction avec len_tot = compteur
===================================================== */

// deplacer le pointeur de data pour pointer sur les donnees correctes
// free la memoire du chainon utilise
void	ft_move_data_pointer(t_data **data)
{
	t_data	*tmp;

	tmp = (*data);
	(*data) = (*data)->next;
	free (tmp);
}

// ramene tous les elements du segments qui avaient ete places en bas de A
void	ft_bring_back_elements_from_a(t_stack **a, t_stack **b, int *count)
{
	int	steps;

	steps = *count;
	ft_printf("steps in bring back = %d\n", steps);
	ft_print_both_lists(*a, *b);
	if ((*count) == 0)
		return ;
	else if ((*count) == 1)
	{
		reverse_rotate(a, 'a');
		(*count)--;
	}
	else
	{
		while (steps > 0)
		{
			reverse_rotate(a, 'a');
			if ((*a)->idx != (*a)->next->idx - 1)
			{
				push(b, a, 'b');
				(*count)++;
			}
			(*count)--;
			steps--;
		}
	}
	ft_printf("count after bringing back from a = %d\n", (*count));
	ft_print_both_lists(*a, *b);
}

// boucle pour retrouver le target que l'on a trouve precedemment
int	ft_find_target(t_stack **a, t_stack **b, int target, int *count, int s)
{
	int	steps;
	int	items_to_bring_to_top;

	items_to_bring_to_top = 0;
	steps = ft_find_shortest_path(*b, target);
	if (ft_is_in_list(b, target) == 0)
	{
		while (1)
		{
			if ((*b)->idx == target)
			{
				push(a, b, 'a');
				if (s == 1)
				{
					rotate(a, 'a');
					items_to_bring_to_top++;
				}
				(*count)--;
				break ;
			}
			else if ((*a)->next->idx == target)
				swap(b, 'b');
			else
				if (steps-- > 0)
					rotate(b, 'b');
				else if (steps++ < 0)
					reverse_rotate(b, 'b');
		}
	}
	return (items_to_bring_to_top);
}

int	ft_find_minimum(t_stack **head, int minimum, int target_high)
{
	t_stack	*tmp;
	int		num;

	tmp = *head;
	num = target_high;
	while (tmp != NULL)
	{
		if (tmp->idx < num && tmp->idx >= minimum && tmp->idx <= target_high)
			num = tmp->idx;
		tmp = tmp->next;
	}
	ft_printf("minimum num = %d\n", num);
	return (num);
}

void	ft_sort_back_a(t_stack **a, int items)
{
	ft_printf("sorting back from bottom of A (already in order)\n");
	while (items-- > 0)
		reverse_rotate(a, 'a');
}

// sorts the remaining part of the split that has been stored in the bottom
// of B
void	ft_sort_rest_of_split(t_stack **a, t_stack **b, int count, int minimum)
{
	int	target;
	int	target_high;
	int	target_low;
	int	steps_high;
	int	steps_low;
	int	items;

	items = 0;
	while (count > 0)
	{
		target_high = (*a)->idx - 1;
		target_low = ft_find_minimum(b, minimum, target_high);
		ft_print_both_lists(*a, *b);
		ft_printf("target high = %d target low = %d\n", target_high, target_low);
		// if (ft_is_in_list(b, target_high) == 1 || ft_is_in_list(b, target_low == 1))
		// 	ft_error_handler(4);
		steps_high = ft_find_shortest_path(*b, target_high);
		steps_low = ft_find_shortest_path(*b, minimum);
		target = target_low;
		if (((unsigned)steps_low >= (unsigned)steps_high)
			|| ((*b)->next != NULL && (*b)->next->idx == target_high))
			target = target_high;
		ft_printf("count = %d target = %d\n", count, target);
		if (target == target_high)
			items += ft_find_target(a, b, target, &count, 0);
		else
			items += ft_find_target(a, b, target, &count, 1);
	}
	ft_sort_back_a(a, items);
}

// case 1 of the plan
void	ft_push_or_swap_to_a(t_stack **a, t_stack **b, int *steps)
{
	int	target;

	target = (*a)->idx - 1;
	if ((*b)->next != NULL && (*b)->next->idx == target)
		swap(b, 'b');
	push(a, b, 'a');
	(*steps)--;
}

// case 2 of the plan
void	ft_push_to_bottom_of_a(t_stack **a, t_stack **b, t_ct *n)
{
	push(a, b, 'a');
	rotate(a, 'a');
	n->count_a++;
	n->steps--;
}

// case 3 of the plan
void	ft_rotate_to_bottom_of_b(t_stack **b, t_ct *n)
{
	rotate(b, 'b');
	n->count_b++;
	n->steps--;
}

// loops through steps elements of A and stores them accordingly to plan
void	ft_loop_for_quick_sort(t_stack **a, t_stack **b, t_data **data, t_ct *n)
{
	int		target;
	int		current;
	
	n->steps = (*data)->to_transfer;
	while (n->steps > 0)
	{
		target = (*a)->idx - 1;
		current = (*b)->idx;
		if (current == target || ((*b)->next != NULL && (*b)->next->idx == target))
			ft_push_or_swap_to_a(a, b, &n->steps);
		else if (current < (*data)->med)
			ft_push_to_bottom_of_a(a, b, n);
		else if (current >= (*data)->med)
			ft_rotate_to_bottom_of_b(b, n);
	}
}
// fonction principale. CF haut de page
void	ft_quick_sort(t_stack **a, t_stack **b, t_data **data)
{
	t_ct	n;
	
	n.count_a = 0;
	n.count_b = 0;
	n.steps = (*data)->to_transfer;
	ft_pre_conditions(*a, *b, *data);
	ft_printf("\n\n\ncommencement\n");
	ft_print_both_lists(*a, *b);
	ft_printf("steps = %d\n\n\n\n", n.steps);
	ft_loop_for_quick_sort(a, b, data, &n);
	if (n.count_b > 0)
		ft_sort_rest_of_split(a, b, n.count_b, (*data)->med);
	if (n.count_a > 0)
	{
		ft_bring_back_elements_from_a(a, b, &n.count_a);
		if (n.count_a > 0)
			ft_sort_rest_of_split(a, b, n.count_a, (*data)->min);
	}
	if (*b == NULL)
		ft_fini(*a, *b, *data);
	ft_move_data_pointer(data);
	ft_printf("fini count a = %d count b = %d\n", n.count_a, n.count_b);
	ft_print_both_lists(*a, *b);
	ft_print_med(*data);
	ft_quick_sort(a, b, data);
}